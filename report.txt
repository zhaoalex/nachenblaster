Alex Zhao
CS 32, Project 3
report.txt

1) Description of each public member function in each class, why it's defined in that class, why it's virtual or not

For each class, constructors and destructors are public, and destructors are virtual because each portion of each object has to be destructed (to avoid memory leaks). Constructors will initalize its base class in the initalizer list as well as any member variables, and in general, destructors have no code (unless I explicitly state they do below).

Also for each class, nearly all doSomething()s will first check if it is dead or not, and will exit immediately if it is; then, it will check whether it goes off the left or right sides of the screen, and call setDead() and return if it is. Only Explosion (because it dies on a timer), Goodie (because it also checks if it goes off the top and bottom sides of the screen), and NachenBlaster (because it cannot go off the sides of the screen) do not follow this rule. Each actor needs a doSomething() because StudentWorld calls this function every tick to allow the Actors to act.

In StudentWorld:
~StudentWorld() will call cleanUp() to free any allocated memory.

init(), move(), and cleanUp() are all public and virtual because they're derived from GameWorld's virtual functions and are called by GameController. Nothing else in StudentWorld is virtual because nothing is derived from StudentWorld.

DamageableObject* getCollidingAlien(const Actor* a) takes in an Actor pointer and returns a pointer to the first alien that collides with that actor (or nullptr if there are none). Collision is checked using the euclidian distance formula given in the spec. It's in StudentWorld because we let the world handle collisions with any actors in that world.

NachenBlaster* getCollidingPlayer(const Actor* a) takes in an Actor and returns a pointer to the player if it collided with the player (or nullptr if it didn't). Collision is handled the same way. It's in StudentWorld because again, we let the world handle collisions with any actors in that world.

bool playerInLineOfFire(const Actor* a) takes in an Actor and returns true if the player is in that actor's line of fire. It's in StudentWorld because we let StudentWorld handle interactions between multiple actors.

void addActor(Actor* a) adds a new actor to the world. It's in StudentWorld because StudentWorld manages all actors in the game.

void recordAlienOnScreen() records that a new alien was added to the screen, since we need to keep track of how many aliens are currently on the screen in order to determine whether to add new aliens to the screen. It's in StudentWorld because we determine whether to add new actors within move().

void recordAlienOffScreen() records that an alien was removed from the screen for the same reason.

void recordAlienDestroyed() records that an alien was destroyed (not just removed from the screen). It's in StudentWorld because we need to keep track of how many aliens are left to destroy in that level.


In Actor:
void doSomething() is called for every actor and every tick, and it determines what each actor does. It is pure virtual because every Actor does something, and does it in a different way.

bool isAlive() returns whether the actor is alive or dead. It is in the Actor base class because each actor will be either alive or dead, and StudentWorld uses death to determine whether or not that actor gets deleted.

bool isAlien() returns whether or not the actor is an alien. It is virtual because not all actors are aliens, so aliens need to override the function to return true, while all other actors must return false.


In Star:
void doSomething() is derived from Actor (so it's virtual) and moves it left 1 pixel every tick.


In Explosion:
void doSomething() is derived from Actor (so it's virtual) and it increases in size each tick, then is destroyed after 4 ticks.


In DamageableObject:
void doSomething() is pure virtual because every damageable object does something different.

void sufferDamage(double amt, int cause) handles any damageable object suffering damage. It's pure virtual because every damageable object handles taking damage differently. It's in DamageableObject because only damageable objects need to handle taking damage.

void setHealth(double amt) sets the object's health. It's in DamageableObject because only damageable objects have health.

double getHealth() returns the object's current health. It's in DamageableObject for the same reason.


In NachenBlaster:
void doSomething() gets any key inputs, and moves in its appropriate direction if a direction was pressed, or fires a cabbage or torpedo if the appropriate keys were pressed and the player has enough cabbages or torpedos. Then it receives one cabbage point per tick, up to 30 maximum cabbage points.

void incHealth(double amt) increases the player's health, never exceeding 50 hit points. It's in NachenBlaster because the blaster has different logic for increasing health (there's a maximum).

void sufferDamage(double amt, int cause) defines suffering damage for the player; it reduces the player's health by the correct amount, plays the correct sound based on the source of the damage, then checks if the player is dead.

void incTorpedoes(int amt) increases the player's torpedo count. It's in NachenBlaster because only the player has a torpedo supply.

int numTorpedoes() and int numCabbages() return the number of torpedoes and cabbages, respectively. It's in NachenBlaster because only the player has a torpedo and cabbage supply.


In Alien:
Alien() constructor also calls StudentWorld's recordAlienOnScreen(), and ~Alien() destructor also calls StudentWorld's recordAlienOffScreen() in order to keep track of the number of aliens on screen.

void doSomething() checks if the alien collided with the player and returns if it did (logic is described in damageCollidingPlayer()). Projectile collisions are handled in the Projectile class.
Then it determines whether to change the flight plan: if the alien hits the top or bottom of the screen, then it will change its Y direction to down or up respectively, and if the flight length is zero, then it will determine a new Y direction randomly. Then it will randomly generate a new flight path length if those conditions were met (unless the alien does not have a flight length).
Then it will determine whether or not to fire at the player by first checking if the player is in its line of fire (StudentWorld's playerInLineOfFire()), and calling possiblyFireAtPlayer() if it is. If possiblyFireAtPlayer() returns true, then the function returns.
Then it will move in its specified travel direction and reduce the flight length.
Finally, it will check collision once more (again, using damageCollidingPlayer()).
This function is in Alien because all Aliens share the same basic doSomething(), only overriding necessary functions.

void sufferDamage(double amt, int cause) defines suffering damage for the alien; it reduces the alien's health by the correct amount, checks if the alien died and calls die() (a private function) if it did; otherwise it plays the appropriate sound.
(die() sets the alien to dead, increases the score appropriately, plays the correct sound, adds an explosion, possibly drops a goodie (by calling possiblyDropGoodie()), then makes the StudentWorld record that an alien was destroyed (StudentWorld's recordAlienDestroyed()).)

bool isAlien() overrides Actor's isAlien() to return true. It's in Alien because only aliens are Aliens.


In Smallgon, Smoregon, and Snagglegon:
Smallgon, Smoregon, and Snagglegon have no public member functions other than the constructor and destructor. (There are protected member functions possiblyDropGoodie() and possiblyFireAtPlayer(), both called in the public doSomething().)


In Goodie:
void doSomething() will check if it collided with the player (by calling didCollide(), a private function) and return if it did. Then it will move itself 0.75 pixels down and left, and check collision with the player one more time. It's in Goodie because all Goodies share the same basic doSomething(), only overriding necessary functions.


In ExtraLifeGoodie, RepairGoodie, and TorpedoGoodie:
ExtraLifeGoodie, RepairGoodie, and TorpedoGoodie have no public member functions other than the constructor and destructor. (There is protected member function grantPowerup(NachenBlaster* player), overriding protected pure virtual grantPowerup() in Goodie and called in private didCollide().)


In Projectile:
void doSomething() will check if it collided with an alien or a player (by calling didCollide(), a private function) and return if it did. Then it will move itself left or right by a specified amount, and rotate 20 degrees counter clockwise if that specific projectile rotates. Then it checks collision one more time. It's in Projectile because all Projectiles share exactly the same doSomething(), only differing in their constructors.


In Cabbage, Turnip, PlayerLaunchedTorpedo, AlienLaunchedTorpedo:
Cabbage, Turnip, PlayerLaunchedTorpedo, and AlienLaunchedTorpedo have no public member functions other than the constructor and destructor.



2) Anything failed to finish / has bugs

I managed to finish everything, and my code has no bugs as far as personal testing and the sanity checker have shown.


3) Design decisions / assumptions

My design structure was similar to the one provided, with a few changes. Here is my hierarchy tree:

GameWorld
	StudentWorld
GraphObject
	Actor
		Star
		Explosion
		DamageableObject
			NachenBlaster
			Alien
				Smallgon
				Smoregon
				Snagglegon
		Goodie
			ExtraLifeGoodie
			RepairGoodie
			TorpedoGoodie
		Projectile
			Cabbage
			Turnip
			PlayerLaunchedTorpedo
			AlienLaunchedTorpedo

To briefly describe the layout, StudentWorld extends GameWorld, of course, and handles most interactions between different actors; that's why it handles checking for collision and player in line of fire. It also handles general game details, like init()/move()/cleanUp(), managing and adding actors, and more.

Actor extends GraphObject and is the base class for all Actors in the game. It simply acts as an abstract base class with doSometthing(), getting and getting living/dead state, getting the StudentWorld pointer, checking out-of-bounds, and checking isAlien().

Star and Explosion are distinct in that they directly extend Actor without using another abstract base class, since they are fairly simple and do not interact with any other actor in the game. Stars simply scroll left and despawn, and explosions simply last for four ticks before despawn, so there is no need to implement more functionality than what Actor provides.

DamageableObject handled anything that had health and could be damaged, namely the NachenBlaster and all Aliens. It added getting/setting health and a function to handle suffering damage; otherwise, this class was also a container class.

Alien handled all aliens in the game, and in addition to overriding isAlien() to return true, it also added functions to drop goodies, fire at the player, and handle collision with the player. It also added flight speed, flight path length and direction, a score value, and ramming damage. The Alien base class actually implemented all Alien logic, except for dropping goodies and firing at the player, which Smallgon, Smoregon, and Snagglegon dealt with in their own ways; I did this to make it easier to add a new Alien in the future if needed.

Goodie handled all goodies in the game (and directly extended Actor), and added functions to grant powerups and check for collisions with the player. Again, all logic was implemented in the Goodie base class, and ExtraLifeGoodie, RepairGoodie, and Torpedo only dealt with granting different powerups; again, I designed it this way so adding new goodies would be easy.

Projectile handled all projectiles in the game (and directly extended Actor), and handled collision with both the player and aliens, damage amounts, speed, rotation, and enemy type. Again, all logic was implemented in the Projectile base class; in fact, Cabbage, Turnip, PlayerLaunchedTorpedo, and AlienLaunchedTorpedo contain their constructors and destructors and nothing more. (Like the example hierarchy, I chose to have two separate classes for Player- and AlienLaunchedTorpedoes, but I saw no need to have a base Torpedo class since the construction was so simple with my design.) This makes it extremely easy to add new Projectiles in the future.

During this project, I did make some different design decisions and assumptions. While all collision checking was done in StudentWorld, I had different classes handle different collisions. Under my design, NachenBlaster handles no collisions on its own. Goodies handle colliding with the player, Projectiles handle colliding with both the player and all aliens, and Aliens only handle colliding with the player (unlike both players and projectiles, like the spec says; under this design, the end result is the same, as mentioned in the FAQ).

For StudentWorld, it wasn't specified what container to use to store actors. I used a STL vector to store all actors because it offers fast access, which is good because we access the container 20 times a second; additionally, the main benefit of using a list (constant time insertion) is not needed here because I add all new actors to the end of the container. I assumed that attempting to introduce new stars and aliens into the game was done at the end of move(), after all Actors' doSomething()s had been called and dead game objects had been removed. Additionally, I chose to leave the NachenBlaster object in the actor container so special logic wouldn't be needed when calling doSomething(), and simply added a member variable in StudentWorld pointing to the NachenBlaster object so that getting the player would be easier. 

One design decision I made in the Alien class was to have a flight plan length member variable for all Aliens (i.e. in the Alien class), even though Snaggletons don't have a flight length. What I chose to do was pass in a boolean in the constructor saying whether that alien uses a flight length or not, then initalized the length to either 0 (as defined in the spec for flight length aliens) or -1 (for non-flight-length aliens). This way, since the variable was decremented every tick, every m_flightLength == 0 check would be reached for aliens that used flight length, but would never be reached for non-flight-length aliens (since the variable started at -1 and kept decrementing). I chose to do this in order to simplify code, as I also knew that the variable would realistically never hit INT_MIN (the alien would be destroyed before that), so no real problems would arise.



4) How you tested each class (1-2 paragraphs per class)

